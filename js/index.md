1.  说下继承的几种方式和优缺点？

    > 代码实现见`./inherit.js`

    > 1. 原型链继承；将父类的实例作为子类的原型
    >    优点：子类可以通过原型链的查找，实现父类的属性公用

         缺点：1. 不能给父类构造函数传递参数；
               2. 父类使用this 声明的属性被所有实例共享，在多个实例之间对引用类型数据操作会互相影响

    > 2. 借用构造函数继承：使用父类的构造函数来增强子类，即复制父类的实例属性给子类

         优点：可向父类构造函数传递参数，而且解决了原型链继承中：父类属性使用this声明的属性会在所有实例共享的问题。
         缺点：1. 只能继承父类通过this声明的属性和方法，不能继承父类prototype上的属性和方法
               2. 本质是复制，每次子类实例化都会重新执行一遍父类的构造函数，父类方法无法复用

    > 3. 组合继承（原型 + 借用构造）：组合两种方法，以原型链实现对父类原型属性和方法的继承，用借用构造函数实现实例属性的继承

         优点：1. 利用原型链继承，实现原型对象方法的继承
               2. 利用构造函数继承，实现属性的继承，而且可以参数

         缺点：无论什么情况下，都会调用两次父级构造函数：一次是在创建子级原型的时候，另一次是在子级构造函数内部

    > 4. 原型式继承：利用一个空对象作为中介，将对象直接赋值给空对象构造函数的原型，然后返回这个函数的调用，这个函数就变成了个可随意增添属性的实例或对象，（Object.create(obj)）

         优点：从已有对象衍生新对象，不需要创建自定义类型
         缺点：与原型链继承一样，多个实例共享被继承对象的属性，存在篡改的可能，也不能传参

    > 5. 寄生式继承：在原型式继承的基础上，创建一个仅用于封装继承过程的函数

         优点：没有创建自定义类型
         缺点：同原型式继承

    > 6. 寄生组合式继承：结合借用构造函数传递参数和寄生模式实现继承

         优点：1. 只调用一个父类的构造函数。
               2. 避免在子类的 prototype 上创建多余属性
               3. 最成熟的继承方案，最常用的继承方案

    > 7. extend 继承：语法糖，核心还是寄生组合式继承

    tips: 1. `__proto__` 已从 web 标准中删除，因为通过这个改变对象的[[prototype]]属性，在每一个 js 引擎和浏览器中都是一个非常慢且影响性能的操作，影响包括所有继承来自该 [[Prototype]]的对象 2. ` Son.protoType = Object.create(Father.prototype);` 相比`Son.prototype = new Father()`，前者只继承原型链上方法，后者还会将父类的内部属性加到原型链上

2.  闭包的理解？

    > 使用闭包可以实现私有方法和变量，优点是可以避免全局变量的污染，缺点是闭包中被引用的变量不会被回收，使用不当会造成内存泄漏
    >
    > 1. 函数嵌套函数
    > 2. 内层函数可以访问到外层函数的作用域的参数和变量
    > 3. 被引用的参数和变量不会被回收

3.  异步加载和延迟加载？

    > 异步加载：

    1. 动态插入 script 标签
    2. 通过 ajax 去获取代码，然后通过 eval 执行
    3. script 标签上添加 defer 或者 async 属性
    4. 创建并插入 iframe，让它异步执行 js

    > 延迟加载：

    1. 有些 js 代码初始化时不需要，之后的使用才可能需要

4.  遍历对象的方法？

    > 1.  for in 遍历对象除 symbol 以外的可枚举属性
    > 2.  object.keys(),去遍历
    > 3.  Object.getOwnPropertyNames(obj),返回一个包含对象所有属性的数组（不含 symbol，包含不可枚举属性）

5.  Map 和 object 区别?

    > 1. Map 的键可以是任意值；object 的键只能是 string 或者 number
    > 2. Map 的键是有顺序的，以插入顺序作为迭代顺序；object 的键是无序的
    > 3. Map 的键值对个数可以通过 size 属性获取，object 只能手动计算
    > 4. Map 是 iterable 的，可以直接迭代；object 只能先获取键，再用键去迭代
    > 5. Map 频繁增删键值对的性能更好；object 未对频繁增删键值对做出优化
    >    tips: object 不是纯粹的 hash 表

6.  promise 的静态方法？

    > 1. promise.all(): 所有 promise 都成功即返回结果，有一个失败就直接返回失败，返回值顺序和参数顺序保持一致
    > 2. promise.race():返回一个 promise，一旦参数中有一个 promise 成功或失败，返回的 promise 就会成功或者失败
    > 3. promise.finally():返回一个 promise，在 promise 执行结束，无论成功还是失败都会执行指定的回调函数
    > 4. promise.then():返回一个 promise，接受两个参数，成功和失败的回调
    > 5. promise.catch():返回一个 promise 处理拒绝的情况
    > 6. promise.allSettled():所有 promise 都完成或失败后，返回一个 promise
    > 7. promise.any():所有 promise 都失败即返回一个失败的 promise，有一个成功就直接返回成功，本质上和 promise.all 相反

7.  函数声明和函数表达式区别和用法？

    > 函数声明：函数声明会被提升到最上方，所以无论函数在哪里声明都可以执行
    > 函数表达式：声明之前无法执行

8.  new 的具体过程？

    > 1. 创建一个空的简单 javascript 对象（即 {}）
    > 2. 链接该对象（设置该对象的 constrcutor）到另一个对象
    > 3. 将步骤一新创建的对象作为 this 的上下文
    > 4. 如果该函数没有返回对象，则返回 this

9.  TypeScript 对比于 Flow 的优势？

    > 1. Flow 相比于 TypeScript 编辑器或者 IDE 集成度低。
    > 2. 社区力量较弱，库的数量较少，而且库的类型定义质量不高。
    > 3. Facebook Flow 团队与社区之间缺乏互动，而且没有公共路线图。
    > 4. 高内存消耗和频繁的内存泄露，有时甚至能占到 10G。

10. 介绍下 Set、Map、WeakSet 和 WeakMap 的区别？

    > Set：类数组，可以存储各种数据类型，可遍历，元素唯一，NAN 只能存一个可用做数组去重
    > Map：key、value 都能是各种数据类型，可遍历，for in,遍历有序
    > WeakMap：key 只能是对象，value 可以是任意数据类型，key 是对对象的弱引用，不可遍历，如果没有其它引用，对象会被 gc 掉，防止内存泄漏，用作存储 dom 结构
    > WeakSet：只能存储对象，也是弱引用，不可遍历

11. 什么是 softbind?

    > 原生 bind，在 bind 多次的情况下，始终以第一次 bind 为准。

12. 什么是防抖和节流？有什么区别？如何实现？

    > 节流：一段时间内最多只执行一次操作，降低函数的执行频率，如滚动页面时计算高度函数
    > 防抖：操作的间隔未达到指定时间不触发操作，如一般搜索框一直输入不触发搜索，

13. ['1', '2', '3'].map(parseInt) what & why ?

    > [1,NAN,NAN]

14. 模块化的演化过程

    > step1:文件划分方式。基于约定，每个文件是一个模块，通过 script 标签引入 html，缺点：在模块部可访问、修改模块内容，没有独立的命名空间，无法管理模块依赖关系，难以分辨成员所属的模块。
    > step2:命名空间方式。每个模块一个命名空间，模块内容都挂在同一个全局对象下。只解决了命名冲突的问题，其他问题依旧存在。
    > step3:IIFE。模块成员都放在立即执行函数形成的私有作用域中，将需要暴露的成员挂载到全局对象上。解决了命名冲突和作用域污染的问题。
    > step4:IIFE 依赖参数,依赖作为 IIFE 参数传入，依赖关系明显。

15. CommonJS 和 ESM 对于模块循环加载处理的区别？

    > CommonJS 模块是加载时执行。一旦出现某个模块被循环加载，就只输出已执行的部分，没有执行的部分不会输出。
    > ESM 对于导出模块，变量，对象是动态引用，遇到模块加载命令 import 时不会去执行模块，只是生成一个指向被加载模块的引用。
    > tips: CommonJS 模块规范主要适用于后端 Node.js,Node.js 是同步加载模块

16. 为什么循环依赖不好？

    > 组件之间的循环依赖性阻碍了理解，测试和重用（您需要了解两个组件才能使用其中之一）。这使系统的可维护性降低，因为难以理解代码。缺乏理解会使更改变得更加困难，并且更容易出错。同样，如果组件具有循环依赖关系，则它们将更难以测试，因为它们无法单独进行测试。循环依赖性可能会在软件系统中引起有害的副作用。当您对软件系统进行较小的更改时，可能会对其他模块产生连锁反应，从而导致全局后果（错误，崩溃等）。最后，如果两个模块紧密耦合并且相互依赖，那么单个模块的重用将变得极为困难，甚至无法实现。

17. 面向对象编程？

    > 面向对象（OOP）是一种计算机编程架构，OOP 达到了软件工程三个主要目标：重用行、灵活性、拓展性。
    > 面向对象程序设计方法是尽可能模拟人类的思维方式，使得软件的开发方法与过程尽可能接近人类认识世界，解决现实问题的方法和过程，把客观世界中的实体
    > 抽象为问题域中的对象。
    > 特点：封装性、继承性、多态性。

18. 面向对象程序设计对于面向过程程序设计的优点？

    > 1.  数据抽象的概念可以在保持外部接口不变的情况下修改内部实现，从而减少甚至避免对外界的干扰。
    > 2.  通过继承减少大幅冗余代码，并可以方便拓展现有代码，提高编码效率，降低出错概率，提升软件可维护性。
    > 3.  结合面向对象分析、面向对象设计，允许将问题域中的对象直接映射到程序中，减少软件开发过程中间环节的转换过程。
    > 4.  通过对对象的辨别、划分可以将软件系统分割为若干相对为独立的部分，在一定程度上更便于控制软件复杂度。
    > 5.  以对象为中心的设计可以帮助开发人员从静态（属性）和动态（方法）两个方面把握问题，从而更好地实现系统。
    > 6.  通过对象的聚合、联合可以在保证封装与抽象的原则下实现对象在内在结构以及外在功能上的扩充，从而实现对象由低到高的升级。

19. ECMAScript 和 JavaScript 的区别？

    > ECMAScript 是形成 JavaScript 语言基础的脚本语言。
    > ECMAScript 是由 Ecma 国际标准组织以 ECMA-262 和 ECMA-402 规范的形式进行标准化的。
    > JavaScript 遵循 ECMAScript 标准,JavaScript 是 ECMAScript 的实例。
    > ECMAScript 是基于 JavaScript 的，而 JavaScript 也是基于 ECMAScript 的，两者密不可分。

20. async/await 和 promise 相比较？

    >

21. 解释下原型链和原型对象？

    > 原型链：javaScript 常被描述为一种基于原型的语言，每个对象拥有一个原型对象，对象以其原型为模板，从原型继承方法和属性，原型对象也可能拥有原型，并从中继承方法和属性，一层一层，以此类推，这种关系常被称为原型链，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。
    > 原型对象：原型对象是一个内部对象`[[prototype]]`，应该使用 Object.getPrototypeof() 或者 `__proto__` 访问
