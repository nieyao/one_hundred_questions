1.  说下继承的几种方式和优缺点？

    > 代码实现见`./inherit.js`

    > 1. 原型链继承；将父类的实例作为子类的原型
    >    优点：子类可以通过原型链的查找，实现父类的属性公用

         缺点：1. 不能给父类构造函数传递参数；
               2. 父类使用this 声明的属性被所有实例共享，在多个实例之间对引用类型数据操作会互相影响

    > 2. 借用构造函数继承：使用父类的构造函数来增强子类，即复制父类的实例属性给子类

         优点：可向父类构造函数传递参数，而且解决了原型链继承中：父类属性使用this声明的属性会在所有实例共享的问题。
         缺点：1. 只能继承父类通过this声明的属性和方法，不能继承父类prototype上的属性和方法
               2. 本质是复制，每次子类实例化都会重新实行一遍父类的构造函数，父类方法无法复用

    > 3. 组合继承（原型 + 借用构造）：组合两种方法，以原型链实现对父类原型属性和方法的继承，用借用构造函数实现实例属性的继承

         优点：1. 利用原型链继承，实现原型对象方法的继承
               2. 利用构造函数继承，实现属性的继承，而且可以参数

         缺点：无论什么情况下，都会调用两次父级构造函数：一次是在创建子级原型的时候，另一次是在子级构造函数内部

    > 4. 原型式继承：利用一个空对象作为中介，将对象直接赋值给空对象构造函数的原型，然后返回这个函数的调用，这个函数就变成了个可随意增添属性的实例或对象，（Object.create(obj)）

         优点：从已有对象衍生新对象，不需要创建自定义类型
         缺点：与原型链继承一样，多个实例共享被继承对象的属性，存在篡改的可能，也不能传参

    > 5. 寄生式继承：在原型式继承的基础上，创建一个仅用于封装继承过程的函数

         优点：没有创建自定义类型
         缺点：同原型式继承

    > 6. 寄生组合式继承：结合借用构造函数传递参数和寄生模式实现继承

         优点：1. 只调用一个父类的构造函数。
               2. 避免在子类的 prototype 上创建多余属性
               3. 最成熟的继承方案，最常用的继承方案

    > 7. extend 继承：语法糖，核心还是寄生组合式继承

    tips: 1. `__proto__` 已从 web 标准中删除，因为通过这个改变对象的[[prototype]]属性，在每一个 js 引擎和浏览器中都是一个非常慢且影响性能的操作，影响包括所有继承来自该 [[Prototype]]的对象 2. ` Son.protoType = Object.create(Father.prototype);` 相比`Son.prototype = new Father()`，前者只继承原型链上方法，后者还会将父类的内部属性加到原型链上

2.  闭包的理解？

    > 使用闭包可以实现私有方法和变量，优点是可以避免全局变量的污染，缺点是闭包中被引用的变量不会被回收，使用不当会造成内存泄漏
    >
    > 1. 函数嵌套函数
    > 2. 内层函数可以访问到外层函数的作用域的参数和变量
    > 3. 被引用的参数和变量不会被回收

3.  异步加载和延迟加载？

    > 异步加载：

    1. 动态插入 script 标签
    2. 通过 ajax 去获取代码，然后通过 eval 执行
    3. script 标签上添加 defer 或者 async 属性
    4. 创建并插入 iframe，让它异步执行 js

    > 延迟加载：

    1. 有些 js 代码初始化时不需要，之后的使用才可能需要

4.  遍历对象的方法？

    > 1.  for in 遍历对象除 symbol 以外的可枚举属性
    > 2.  object.keys(),去遍历
    > 3.  Object.getOwnPropertyNames(obj),返回一个包含对象所有属性的数组（不含 symbol，包含不可枚举属性）

5.  Map 和 object 区别?

    > 1. Map 的键可以是任意值；object 的键只能是 string 或者 number
    > 2. Map 的键是有顺序的，以插入顺序作为迭代顺序；object 的键是无序的
    > 3. Map 的键值对个数可以通过 size 属性获取，object 只能手动计算
    > 4. Map 是 iterable 的，可以直接迭代；object 只能先获取键，再用键去迭代
    > 5. Map 频繁增删键值对的性能更好；object 未对频繁增删键值对做出优化
    >    tips: object 不是纯粹的 hash 表

6.  promise 的静态方法？

    > 1. promise.all(): 所有 promise 都成功即返回结果，有一个失败就直接返回失败，返回值顺序和参数顺序保持一致
    > 2. promise.race():返回一个 promise，一旦参数中有一个 promise 成功或失败，返回的 promise 就会成功或者失败
    > 3. promise.finally():返回一个 promise，在 promise 执行结束，无论成功还是失败都会执行指定的回调函数
    > 4. promise.then():返回一个 promise，接受两个参数，成功和失败的回调
    > 5. promise.catch():返回一个 promise 处理拒绝的情况
    > 6. promise.allSettled():所有 promise 都完成或失败后，返回一个 promise
    > 7. promise.any():所有 promise 都失败即返回一个失败的 promise，有一个成功就直接返回成功，本质上和 promise.all 相反

7.  函数声明和函数表达式区别和用法？

    > 函数声明：函数声明会被提升到最上方，所以无论函数在哪里声明都可以执行
    > 函数表达式：声明之前无法执行

8.  new 的具体过程？

    > 1. 创建一个简单的空的简单 javascript 对象（即 {}）
    > 2. 链接该对象（设置该对象的 constrcutor）到另一个对象
    > 3. 将步骤一新创建的对象作为 this 的上下文
    > 4. 如果该函数没有返回对象，则返回 this

9.  TypeScript 对比于 Flow 的优势？

    > 1. Flow 相比于 TypeScript 编辑器或者 IDE 集成度低。
    > 2. 社区力量较弱，库的数量较少，而且库的类型定义质量不高。
    > 3. Facebook Flow 团队与社区之间缺乏互动，而且没有公共路线图。
    > 4. 高内存消耗和频繁的内存泄露，有时甚至能占到 10G。
