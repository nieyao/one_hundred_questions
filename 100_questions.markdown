1. 写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么?

   > 组件更新时，框架做 diff 算法时可以用 key 标记节点，极大提升 diff 算法的性能，避免更新一些本不需要更新的节点

2. ['1', '2', '3'].map(parseInt) what & why ?

   > [1,NAN,NAN]

3. 什么是防抖和节流？有什么区别？如何实现？

   > 节流：一段时间内最多只执行一次操作，降低函数的执行频率，如滚动页面时计算高度函数
   > 防抖：操作的间隔未达到指定时间不触发操作，如一般搜索框一直输入不触发搜索，

4. 介绍下 Set、Map、WeakSet 和 WeakMap 的区别？

   > Set：类数组，可以存储各种数据类型，可遍历，元素唯一，NAN 只能存一个可用做数组去重
   > Map：key、value 都能是各种数据类型，可遍历，for in,遍历有序
   > WeakMap：key 只能是对象，value 可以是任意数据类型，key 是对对象的弱引用，不可遍历，如果没有其它引用，对象会被 gc 掉，防止内存泄漏，用作存储 dom 结构
   > WeakSet：只能存储对象，也是弱引用，不可遍历

5. 什么是 softbind?

   > 原生 bind，在 bind 多次的情况下，始终以第一次 bind 为准。

6. 模块化的演化过程

   > step1:文件划分方式。基于约定，每个文件是一个模块，通过 script 标签引入 html，缺点：在模块部可访问、修改模块内容，没有独立的命名空间，无法管理模块依赖关系，难以分辨成员所属的模块。
   > step2:命名空间方式。每个模块一个命名空间，模块内容都挂在同一个全局对象下。只解决了命名冲突的问题，其他问题依旧存在。
   > step3:IIFE。模块成员都放在立即执行函数形成的私有作用域中，将需要暴露的成员挂载到全局对象上。解决了命名冲突和作用域污染的问题。
   > step4:IIFE 依赖参数,依赖作为 IIFE 参数传入，依赖关系明显。

7. 什么是 HMR?

   > Hot module Replacement,模块更新，通过 websocket 替换对应模块达到刷新局部的功能，模块更新事件有冒泡机制

8. 网页中的图片资源为什么放在不同的域名下？

   > 浏览器对请求的并发数目限制是针对于域名的，包括一级域名下面的二级域名，所以使用不同的一级域名可以提升并行数目上限，提升资源的获取速度

9. 浏览器与服务器建立一个 tcp 连接后，是否会在完成一个 http 请求后断开，什么条件下会断开？

   > http 1.0,一个请求在接到服务器响应后就会断开连接，如果要维持连接，则要配置 connection:keep-alive,而 http 1.1 把这一行为变成了默认行为，1.1 后除非设置 connection:close，才会在请求完成后断开 tcp 连接

10. 一个 tcp 连接同时可以发送多少个 http 请求？

> http1.1,一个 tcp 一个 http 请求，http2，多路复用，一个 tcp 连接可以同时发送多个 http 请求

12. 浏览器 http 请求的并发性如何体现?,并发请求的数量限制？

> 浏览器会同时和服务器建立多个 tcp 连接，同时发起多个 http 请求，chrome 同时最多 6 个 tcp 连接，不同浏览器稍有差异

13. 浏览器的同源策略？

> 同一协议，同一域名，同一端口

14. 谈谈对 styled-component 的吗发

> styled-component 通过给随机类名的方式解决了 css 全局作用域的问题，可以和组件更好的联动，可以用组件里的 props，更耦合，可以继承

15. performance API 中什么指标可以衡量首屏时间？

> window.performance.timing

16. display: inline 的元素设置 margin 和 padding 会生效吗?

> 左右生效，上下不生效

17. 你用 css 实现过什么不错的效果？

18. 伪类和伪元素的区别？

> 伪类使用单冒号，而伪元素使用双冒号。如 :hover 是伪类，::before 是伪元素；
> 伪元素会在文档流生成一个新的元素，并且可以使用 content 属性设置内容。

19. css 如何匹配前 N 个子元素及最后 N 个子元素？

> 如何匹配最前三个子元素: :nth-child(-n+3)
> 如何匹配最后三个子元素: :nth-last-child(-n+3)

20. why react hooks?

> 1. 告别难以理解的 class
>    class 中的 this 指向是难以捉摸的，很烦人，以前我们用 bind 解决 this 的指向问题，后来我们用箭头函数。
>    class 中不不合理的逻辑规划方式，class 中的业务逻辑耦合在生命周期中，同一段逻辑可能散布在几个不同的生命周期中。而且一个生命周期中经常会做几件不同的事
> 2. hooks 解决了业务逻辑难以拆分的问题，
> 3. 组件的逻辑复用，自定义 hooks 让逻辑可以单独成为一个个小的 hooks。让组件间的逻辑复用变得简单,而且不像 hoc 会造成组件嵌套地狱，hooks 可以在不破坏组件结构的同时达到复用组件逻辑的效果。
> 4. hooks 函数式的设计更符合 react 的设计哲学。
>    但 hooks 也不是万能的，目前 hooks 还是有一些不能实现的类组件的能力，如 getSnapshotBeforeUpdate，componentDidCatch；在过于耦合和过度拆分间我们应该找到一个平衡点，这对于开发者的能力提出了更高的要求；还有就是 hooks 是有不少使用规则的，虽然我们通过 hooks 插件可以避免大部分问题，但是如果我们不清楚 hooks 的运行逻辑，还是容易出现问题
